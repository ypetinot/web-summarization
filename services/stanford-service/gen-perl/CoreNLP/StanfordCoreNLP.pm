#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use CoreNLP::Types;

# HELPER FUNCTIONS AND STRUCTURES

package CoreNLP::StanfordCoreNLP_ping_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_ping_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_ping_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_ping_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_ping_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_ping_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_zip_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_zip_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_zip_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_zip_result;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_zip_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_zip_result');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_text_args->mk_accessors( qw( text outputFormat ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{text} = undef;
  $self->{outputFormat} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{text}) {
      $self->{text} = $vals->{text};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{text});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{outputFormat} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $xfer += $input->readString(\$elem5);
            push(@{$self->{outputFormat}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_text_args');
  if (defined $self->{text}) {
    $xfer += $output->writeFieldBegin('text', TType::STRING, 1);
    $xfer += $output->writeString($self->{text});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter6 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter6);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{success} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new CoreNLP::ParseTree();
            $xfer += $elem12->read($input);
            push(@{$self->{success}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter13 (@{$self->{success}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_tokens_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_tokens_args->mk_accessors( qw( tokens outputFormat ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokens} = undef;
  $self->{outputFormat} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokens}) {
      $self->{tokens} = $vals->{tokens};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_tokens_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{tokens} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{tokens}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size20 = 0;
          $self->{outputFormat} = [];
          my $_etype23 = 0;
          $xfer += $input->readListBegin(\$_etype23, \$_size20);
          for (my $_i24 = 0; $_i24 < $_size20; ++$_i24)
          {
            my $elem25 = undef;
            $xfer += $input->readString(\$elem25);
            push(@{$self->{outputFormat}},$elem25);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_tokens_args');
  if (defined $self->{tokens}) {
    $xfer += $output->writeFieldBegin('tokens', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tokens}}));
      {
        foreach my $iter26 (@{$self->{tokens}}) 
        {
          $xfer += $output->writeString($iter26);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter27 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter27);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_tokens_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_tokens_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_tokens_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new CoreNLP::ParseTree();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_tokens_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_tagged_sentence_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_tagged_sentence_args->mk_accessors( qw( taggedSentence outputFormat divider ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{taggedSentence} = undef;
  $self->{outputFormat} = undef;
  $self->{divider} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{taggedSentence}) {
      $self->{taggedSentence} = $vals->{taggedSentence};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
    if (defined $vals->{divider}) {
      $self->{divider} = $vals->{divider};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_tagged_sentence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{taggedSentence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{outputFormat} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $xfer += $input->readString(\$elem33);
            push(@{$self->{outputFormat}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{divider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_tagged_sentence_args');
  if (defined $self->{taggedSentence}) {
    $xfer += $output->writeFieldBegin('taggedSentence', TType::STRING, 1);
    $xfer += $output->writeString($self->{taggedSentence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter34 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter34);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{divider}) {
    $xfer += $output->writeFieldBegin('divider', TType::STRING, 3);
    $xfer += $output->writeString($self->{divider});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_parse_tagged_sentence_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_parse_tagged_sentence_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_parse_tagged_sentence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new CoreNLP::ParseTree();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_parse_tagged_sentence_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_args->mk_accessors( qw( tree ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tree} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tree}) {
      $self->{tree} = $vals->{tree};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_lexicalize_parse_tree_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tree});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_lexicalize_parse_tree_args');
  if (defined $self->{tree}) {
    $xfer += $output->writeFieldBegin('tree', TType::STRING, 1);
    $xfer += $output->writeString($self->{tree});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_lexicalize_parse_tree_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_lexicalize_parse_tree_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_text_args->mk_accessors( qw( text ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{text} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{text}) {
      $self->{text} = $vals->{text};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{text});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_text_args');
  if (defined $self->{text}) {
    $xfer += $output->writeFieldBegin('text', TType::STRING, 1);
    $xfer += $output->writeString($self->{text});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{success} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $elem40 = new CoreNLP::NamedEntity();
            $xfer += $elem40->read($input);
            push(@{$self->{success}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter41 (@{$self->{success}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_tokens_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_tokens_args->mk_accessors( qw( tokens ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokens} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokens}) {
      $self->{tokens} = $vals->{tokens};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_tokens_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{tokens} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $xfer += $input->readString(\$elem47);
            push(@{$self->{tokens}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_tokens_args');
  if (defined $self->{tokens}) {
    $xfer += $output->writeFieldBegin('tokens', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tokens}}));
      {
        foreach my $iter48 (@{$self->{tokens}}) 
        {
          $xfer += $output->writeString($iter48);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_tokens_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_tokens_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_tokens_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size49 = 0;
          $self->{success} = [];
          my $_etype52 = 0;
          $xfer += $input->readListBegin(\$_etype52, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $elem54 = undef;
            $elem54 = new CoreNLP::NamedEntity();
            $xfer += $elem54->read($input);
            push(@{$self->{success}},$elem54);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_tokens_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter55 (@{$self->{success}}) 
        {
          $xfer += ${iter55}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_trees_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_trees_args->mk_accessors( qw( trees ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{trees} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{trees}) {
      $self->{trees} = $vals->{trees};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_trees_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size56 = 0;
          $self->{trees} = [];
          my $_etype59 = 0;
          $xfer += $input->readListBegin(\$_etype59, \$_size56);
          for (my $_i60 = 0; $_i60 < $_size56; ++$_i60)
          {
            my $elem61 = undef;
            $xfer += $input->readString(\$elem61);
            push(@{$self->{trees}},$elem61);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_trees_args');
  if (defined $self->{trees}) {
    $xfer += $output->writeFieldBegin('trees', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{trees}}));
      {
        foreach my $iter62 (@{$self->{trees}}) 
        {
          $xfer += $output->writeString($iter62);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_get_entities_from_trees_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_get_entities_from_trees_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_get_entities_from_trees_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size63 = 0;
          $self->{success} = [];
          my $_etype66 = 0;
          $xfer += $input->readListBegin(\$_etype66, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $elem68 = undef;
            $elem68 = new CoreNLP::NamedEntity();
            $xfer += $elem68->read($input);
            push(@{$self->{success}},$elem68);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_get_entities_from_trees_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter69 (@{$self->{success}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_args->mk_accessors( qw( text ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{text} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{text}) {
      $self->{text} = $vals->{text};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{text});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_text_args');
  if (defined $self->{text}) {
    $xfer += $output->writeFieldBegin('text', TType::STRING, 1);
    $xfer += $output->writeString($self->{text});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size70 = 0;
          $self->{success} = [];
          my $_etype73 = 0;
          $xfer += $input->readListBegin(\$_etype73, \$_size70);
          for (my $_i74 = 0; $_i74 < $_size70; ++$_i74)
          {
            my $elem75 = undef;
            $xfer += $input->readString(\$elem75);
            push(@{$self->{success}},$elem75);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter76 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter76);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args->mk_accessors( qw( sentencesWithTokensSeparatedBySpace ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sentencesWithTokensSeparatedBySpace} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sentencesWithTokensSeparatedBySpace}) {
      $self->{sentencesWithTokensSeparatedBySpace} = $vals->{sentencesWithTokensSeparatedBySpace};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size77 = 0;
          $self->{sentencesWithTokensSeparatedBySpace} = [];
          my $_etype80 = 0;
          $xfer += $input->readListBegin(\$_etype80, \$_size77);
          for (my $_i81 = 0; $_i81 < $_size77; ++$_i81)
          {
            my $elem82 = undef;
            $xfer += $input->readString(\$elem82);
            push(@{$self->{sentencesWithTokensSeparatedBySpace}},$elem82);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args');
  if (defined $self->{sentencesWithTokensSeparatedBySpace}) {
    $xfer += $output->writeFieldBegin('sentencesWithTokensSeparatedBySpace', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{sentencesWithTokensSeparatedBySpace}}));
      {
        foreach my $iter83 (@{$self->{sentencesWithTokensSeparatedBySpace}}) 
        {
          $xfer += $output->writeString($iter83);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size84 = 0;
          $self->{success} = [];
          my $_etype87 = 0;
          $xfer += $input->readListBegin(\$_etype87, \$_size84);
          for (my $_i88 = 0; $_i88 < $_size84; ++$_i88)
          {
            my $elem89 = undef;
            $xfer += $input->readString(\$elem89);
            push(@{$self->{success}},$elem89);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter90 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter90);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_args->mk_accessors( qw( trees ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{trees} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{trees}) {
      $self->{trees} = $vals->{trees};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_trees_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size91 = 0;
          $self->{trees} = [];
          my $_etype94 = 0;
          $xfer += $input->readListBegin(\$_etype94, \$_size91);
          for (my $_i95 = 0; $_i95 < $_size91; ++$_i95)
          {
            my $elem96 = undef;
            $xfer += $input->readString(\$elem96);
            push(@{$self->{trees}},$elem96);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_trees_args');
  if (defined $self->{trees}) {
    $xfer += $output->writeFieldBegin('trees', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{trees}}));
      {
        foreach my $iter97 (@{$self->{trees}}) 
        {
          $xfer += $output->writeString($iter97);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_resolve_coreferences_in_trees_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size98 = 0;
          $self->{success} = [];
          my $_etype101 = 0;
          $xfer += $input->readListBegin(\$_etype101, \$_size98);
          for (my $_i102 = 0; $_i102 < $_size98; ++$_i102)
          {
            my $elem103 = undef;
            $xfer += $input->readString(\$elem103);
            push(@{$self->{success}},$elem103);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_resolve_coreferences_in_trees_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter104 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter104);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_args->mk_accessors( qw( parseTree tregexPattern ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{parseTree} = undef;
  $self->{tregexPattern} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{parseTree}) {
      $self->{parseTree} = $vals->{parseTree};
    }
    if (defined $vals->{tregexPattern}) {
      $self->{tregexPattern} = $vals->{tregexPattern};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_evaluate_tregex_pattern_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{parseTree});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tregexPattern});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_evaluate_tregex_pattern_args');
  if (defined $self->{parseTree}) {
    $xfer += $output->writeFieldBegin('parseTree', TType::STRING, 1);
    $xfer += $output->writeString($self->{parseTree});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tregexPattern}) {
    $xfer += $output->writeFieldBegin('tregexPattern', TType::STRING, 2);
    $xfer += $output->writeString($self->{tregexPattern});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_evaluate_tregex_pattern_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size105 = 0;
          $self->{success} = [];
          my $_etype108 = 0;
          $xfer += $input->readListBegin(\$_etype108, \$_size105);
          for (my $_i109 = 0; $_i109 < $_size105; ++$_i109)
          {
            my $elem110 = undef;
            $xfer += $input->readString(\$elem110);
            push(@{$self->{success}},$elem110);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_evaluate_tregex_pattern_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter111 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter111);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tag_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tag_text_args->mk_accessors( qw( untokenizedText ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{untokenizedText} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{untokenizedText}) {
      $self->{untokenizedText} = $vals->{untokenizedText};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tag_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{untokenizedText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tag_text_args');
  if (defined $self->{untokenizedText}) {
    $xfer += $output->writeFieldBegin('untokenizedText', TType::STRING, 1);
    $xfer += $output->writeString($self->{untokenizedText});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tag_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tag_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tag_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size112 = 0;
          $self->{success} = [];
          my $_etype115 = 0;
          $xfer += $input->readListBegin(\$_etype115, \$_size112);
          for (my $_i116 = 0; $_i116 < $_size112; ++$_i116)
          {
            my $elem117 = undef;
            {
              my $_size118 = 0;
              $elem117 = [];
              my $_etype121 = 0;
              $xfer += $input->readListBegin(\$_etype121, \$_size118);
              for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
              {
                my $elem123 = undef;
                $elem123 = new CoreNLP::TaggedToken();
                $xfer += $elem123->read($input);
                push(@{$elem117},$elem123);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem117);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tag_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter124 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{${iter124}}));
            {
              foreach my $iter125 (@{${iter124}}) 
              {
                $xfer += ${iter125}->write($output);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_args->mk_accessors( qw( tokenizedSentence ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenizedSentence} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenizedSentence}) {
      $self->{tokenizedSentence} = $vals->{tokenizedSentence};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tag_tokenized_sentence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size126 = 0;
          $self->{tokenizedSentence} = [];
          my $_etype129 = 0;
          $xfer += $input->readListBegin(\$_etype129, \$_size126);
          for (my $_i130 = 0; $_i130 < $_size126; ++$_i130)
          {
            my $elem131 = undef;
            $xfer += $input->readString(\$elem131);
            push(@{$self->{tokenizedSentence}},$elem131);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tag_tokenized_sentence_args');
  if (defined $self->{tokenizedSentence}) {
    $xfer += $output->writeFieldBegin('tokenizedSentence', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tokenizedSentence}}));
      {
        foreach my $iter132 (@{$self->{tokenizedSentence}}) 
        {
          $xfer += $output->writeString($iter132);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tag_tokenized_sentence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{success} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $elem138 = new CoreNLP::TaggedToken();
            $xfer += $elem138->read($input);
            push(@{$self->{success}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tag_tokenized_sentence_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter139 (@{$self->{success}}) 
        {
          $xfer += ${iter139}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_untokenize_sentence_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_untokenize_sentence_args->mk_accessors( qw( sentenceTokens ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{sentenceTokens} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{sentenceTokens}) {
      $self->{sentenceTokens} = $vals->{sentenceTokens};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_untokenize_sentence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size140 = 0;
          $self->{sentenceTokens} = [];
          my $_etype143 = 0;
          $xfer += $input->readListBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $xfer += $input->readString(\$elem145);
            push(@{$self->{sentenceTokens}},$elem145);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_untokenize_sentence_args');
  if (defined $self->{sentenceTokens}) {
    $xfer += $output->writeFieldBegin('sentenceTokens', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{sentenceTokens}}));
      {
        foreach my $iter146 (@{$self->{sentenceTokens}}) 
        {
          $xfer += $output->writeString($iter146);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_untokenize_sentence_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_untokenize_sentence_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_untokenize_sentence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_untokenize_sentence_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tokenize_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tokenize_text_args->mk_accessors( qw( arbitraryText ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{arbitraryText} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{arbitraryText}) {
      $self->{arbitraryText} = $vals->{arbitraryText};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tokenize_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{arbitraryText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tokenize_text_args');
  if (defined $self->{arbitraryText}) {
    $xfer += $output->writeFieldBegin('arbitraryText', TType::STRING, 1);
    $xfer += $output->writeString($self->{arbitraryText});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_tokenize_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_tokenize_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_tokenize_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size147 = 0;
          $self->{success} = [];
          my $_etype150 = 0;
          $xfer += $input->readListBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            {
              my $_size153 = 0;
              $elem152 = [];
              my $_etype156 = 0;
              $xfer += $input->readListBegin(\$_etype156, \$_size153);
              for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
              {
                my $elem158 = undef;
                $xfer += $input->readString(\$elem158);
                push(@{$elem152},$elem158);
              }
              $xfer += $input->readListEnd();
            }
            push(@{$self->{success}},$elem152);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_tokenize_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::LIST, scalar(@{$self->{success}}));
      {
        foreach my $iter159 (@{$self->{success}}) 
        {
          {
            $xfer += $output->writeListBegin(TType::STRING, scalar(@{${iter159}}));
            {
              foreach my $iter160 (@{${iter159}}) 
              {
                $xfer += $output->writeString($iter160);
              }
            }
            $xfer += $output->writeListEnd();
          }
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_args->mk_accessors( qw( taggedSentence outputFormat divider ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{taggedSentence} = undef;
  $self->{outputFormat} = undef;
  $self->{divider} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{taggedSentence}) {
      $self->{taggedSentence} = $vals->{taggedSentence};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
    if (defined $vals->{divider}) {
      $self->{divider} = $vals->{divider};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_tagged_sentence_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{taggedSentence});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size161 = 0;
          $self->{outputFormat} = [];
          my $_etype164 = 0;
          $xfer += $input->readListBegin(\$_etype164, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $elem166 = undef;
            $xfer += $input->readString(\$elem166);
            push(@{$self->{outputFormat}},$elem166);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{divider});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_tagged_sentence_args');
  if (defined $self->{taggedSentence}) {
    $xfer += $output->writeFieldBegin('taggedSentence', TType::STRING, 1);
    $xfer += $output->writeString($self->{taggedSentence});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter167 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter167);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{divider}) {
    $xfer += $output->writeFieldBegin('divider', TType::STRING, 3);
    $xfer += $output->writeString($self->{divider});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_tagged_sentence_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new CoreNLP::ParseTree();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_tagged_sentence_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_text_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_text_args->mk_accessors( qw( untokenizedText outputFormat ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{untokenizedText} = undef;
  $self->{outputFormat} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{untokenizedText}) {
      $self->{untokenizedText} = $vals->{untokenizedText};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_text_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{untokenizedText});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size168 = 0;
          $self->{outputFormat} = [];
          my $_etype171 = 0;
          $xfer += $input->readListBegin(\$_etype171, \$_size168);
          for (my $_i172 = 0; $_i172 < $_size168; ++$_i172)
          {
            my $elem173 = undef;
            $xfer += $input->readString(\$elem173);
            push(@{$self->{outputFormat}},$elem173);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_text_args');
  if (defined $self->{untokenizedText}) {
    $xfer += $output->writeFieldBegin('untokenizedText', TType::STRING, 1);
    $xfer += $output->writeString($self->{untokenizedText});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter174 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter174);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_text_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_text_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_text_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size175 = 0;
          $self->{success} = [];
          my $_etype178 = 0;
          $xfer += $input->readListBegin(\$_etype178, \$_size175);
          for (my $_i179 = 0; $_i179 < $_size175; ++$_i179)
          {
            my $elem180 = undef;
            $elem180 = new CoreNLP::ParseTree();
            $xfer += $elem180->read($input);
            push(@{$self->{success}},$elem180);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_text_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter181 (@{$self->{success}}) 
        {
          $xfer += ${iter181}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_tokens_args;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_tokens_args->mk_accessors( qw( tokenizedSentence outputFormat ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tokenizedSentence} = undef;
  $self->{outputFormat} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tokenizedSentence}) {
      $self->{tokenizedSentence} = $vals->{tokenizedSentence};
    }
    if (defined $vals->{outputFormat}) {
      $self->{outputFormat} = $vals->{outputFormat};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_tokens_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size182 = 0;
          $self->{tokenizedSentence} = [];
          my $_etype185 = 0;
          $xfer += $input->readListBegin(\$_etype185, \$_size182);
          for (my $_i186 = 0; $_i186 < $_size182; ++$_i186)
          {
            my $elem187 = undef;
            $xfer += $input->readString(\$elem187);
            push(@{$self->{tokenizedSentence}},$elem187);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size188 = 0;
          $self->{outputFormat} = [];
          my $_etype191 = 0;
          $xfer += $input->readListBegin(\$_etype191, \$_size188);
          for (my $_i192 = 0; $_i192 < $_size188; ++$_i192)
          {
            my $elem193 = undef;
            $xfer += $input->readString(\$elem193);
            push(@{$self->{outputFormat}},$elem193);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_tokens_args');
  if (defined $self->{tokenizedSentence}) {
    $xfer += $output->writeFieldBegin('tokenizedSentence', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{tokenizedSentence}}));
      {
        foreach my $iter194 (@{$self->{tokenizedSentence}}) 
        {
          $xfer += $output->writeString($iter194);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{outputFormat}) {
    $xfer += $output->writeFieldBegin('outputFormat', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{outputFormat}}));
      {
        foreach my $iter195 (@{$self->{outputFormat}}) 
        {
          $xfer += $output->writeString($iter195);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLP_sr_parse_tokens_result;
use base qw(Class::Accessor);
CoreNLP::StanfordCoreNLP_sr_parse_tokens_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'StanfordCoreNLP_sr_parse_tokens_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new CoreNLP::ParseTree();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('StanfordCoreNLP_sr_parse_tokens_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package CoreNLP::StanfordCoreNLPIf;

use strict;


sub ping{
  my $self = shift;

  die 'implement interface';
}

sub zip{
  my $self = shift;

  die 'implement interface';
}

sub parse_text{
  my $self = shift;
  my $text = shift;
  my $outputFormat = shift;

  die 'implement interface';
}

sub parse_tokens{
  my $self = shift;
  my $tokens = shift;
  my $outputFormat = shift;

  die 'implement interface';
}

sub parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

  die 'implement interface';
}

sub lexicalize_parse_tree{
  my $self = shift;
  my $tree = shift;

  die 'implement interface';
}

sub get_entities_from_text{
  my $self = shift;
  my $text = shift;

  die 'implement interface';
}

sub get_entities_from_tokens{
  my $self = shift;
  my $tokens = shift;

  die 'implement interface';
}

sub get_entities_from_trees{
  my $self = shift;
  my $trees = shift;

  die 'implement interface';
}

sub resolve_coreferences_in_text{
  my $self = shift;
  my $text = shift;

  die 'implement interface';
}

sub resolve_coreferences_in_tokenized_sentences{
  my $self = shift;
  my $sentencesWithTokensSeparatedBySpace = shift;

  die 'implement interface';
}

sub resolve_coreferences_in_trees{
  my $self = shift;
  my $trees = shift;

  die 'implement interface';
}

sub evaluate_tregex_pattern{
  my $self = shift;
  my $parseTree = shift;
  my $tregexPattern = shift;

  die 'implement interface';
}

sub tag_text{
  my $self = shift;
  my $untokenizedText = shift;

  die 'implement interface';
}

sub tag_tokenized_sentence{
  my $self = shift;
  my $tokenizedSentence = shift;

  die 'implement interface';
}

sub untokenize_sentence{
  my $self = shift;
  my $sentenceTokens = shift;

  die 'implement interface';
}

sub tokenize_text{
  my $self = shift;
  my $arbitraryText = shift;

  die 'implement interface';
}

sub sr_parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

  die 'implement interface';
}

sub sr_parse_text{
  my $self = shift;
  my $untokenizedText = shift;
  my $outputFormat = shift;

  die 'implement interface';
}

sub sr_parse_tokens{
  my $self = shift;
  my $tokenizedSentence = shift;
  my $outputFormat = shift;

  die 'implement interface';
}

package CoreNLP::StanfordCoreNLPRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub ping{
  my ($self, $request) = @_;

  return $self->{impl}->ping();
}

sub zip{
  my ($self, $request) = @_;

  return $self->{impl}->zip();
}

sub parse_text{
  my ($self, $request) = @_;

  my $text = ($request->{'text'}) ? $request->{'text'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  return $self->{impl}->parse_text($text, $outputFormat);
}

sub parse_tokens{
  my ($self, $request) = @_;

  my $tokens = ($request->{'tokens'}) ? $request->{'tokens'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  return $self->{impl}->parse_tokens($tokens, $outputFormat);
}

sub parse_tagged_sentence{
  my ($self, $request) = @_;

  my $taggedSentence = ($request->{'taggedSentence'}) ? $request->{'taggedSentence'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  my $divider = ($request->{'divider'}) ? $request->{'divider'} : undef;
  return $self->{impl}->parse_tagged_sentence($taggedSentence, $outputFormat, $divider);
}

sub lexicalize_parse_tree{
  my ($self, $request) = @_;

  my $tree = ($request->{'tree'}) ? $request->{'tree'} : undef;
  return $self->{impl}->lexicalize_parse_tree($tree);
}

sub get_entities_from_text{
  my ($self, $request) = @_;

  my $text = ($request->{'text'}) ? $request->{'text'} : undef;
  return $self->{impl}->get_entities_from_text($text);
}

sub get_entities_from_tokens{
  my ($self, $request) = @_;

  my $tokens = ($request->{'tokens'}) ? $request->{'tokens'} : undef;
  return $self->{impl}->get_entities_from_tokens($tokens);
}

sub get_entities_from_trees{
  my ($self, $request) = @_;

  my $trees = ($request->{'trees'}) ? $request->{'trees'} : undef;
  return $self->{impl}->get_entities_from_trees($trees);
}

sub resolve_coreferences_in_text{
  my ($self, $request) = @_;

  my $text = ($request->{'text'}) ? $request->{'text'} : undef;
  return $self->{impl}->resolve_coreferences_in_text($text);
}

sub resolve_coreferences_in_tokenized_sentences{
  my ($self, $request) = @_;

  my $sentencesWithTokensSeparatedBySpace = ($request->{'sentencesWithTokensSeparatedBySpace'}) ? $request->{'sentencesWithTokensSeparatedBySpace'} : undef;
  return $self->{impl}->resolve_coreferences_in_tokenized_sentences($sentencesWithTokensSeparatedBySpace);
}

sub resolve_coreferences_in_trees{
  my ($self, $request) = @_;

  my $trees = ($request->{'trees'}) ? $request->{'trees'} : undef;
  return $self->{impl}->resolve_coreferences_in_trees($trees);
}

sub evaluate_tregex_pattern{
  my ($self, $request) = @_;

  my $parseTree = ($request->{'parseTree'}) ? $request->{'parseTree'} : undef;
  my $tregexPattern = ($request->{'tregexPattern'}) ? $request->{'tregexPattern'} : undef;
  return $self->{impl}->evaluate_tregex_pattern($parseTree, $tregexPattern);
}

sub tag_text{
  my ($self, $request) = @_;

  my $untokenizedText = ($request->{'untokenizedText'}) ? $request->{'untokenizedText'} : undef;
  return $self->{impl}->tag_text($untokenizedText);
}

sub tag_tokenized_sentence{
  my ($self, $request) = @_;

  my $tokenizedSentence = ($request->{'tokenizedSentence'}) ? $request->{'tokenizedSentence'} : undef;
  return $self->{impl}->tag_tokenized_sentence($tokenizedSentence);
}

sub untokenize_sentence{
  my ($self, $request) = @_;

  my $sentenceTokens = ($request->{'sentenceTokens'}) ? $request->{'sentenceTokens'} : undef;
  return $self->{impl}->untokenize_sentence($sentenceTokens);
}

sub tokenize_text{
  my ($self, $request) = @_;

  my $arbitraryText = ($request->{'arbitraryText'}) ? $request->{'arbitraryText'} : undef;
  return $self->{impl}->tokenize_text($arbitraryText);
}

sub sr_parse_tagged_sentence{
  my ($self, $request) = @_;

  my $taggedSentence = ($request->{'taggedSentence'}) ? $request->{'taggedSentence'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  my $divider = ($request->{'divider'}) ? $request->{'divider'} : undef;
  return $self->{impl}->sr_parse_tagged_sentence($taggedSentence, $outputFormat, $divider);
}

sub sr_parse_text{
  my ($self, $request) = @_;

  my $untokenizedText = ($request->{'untokenizedText'}) ? $request->{'untokenizedText'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  return $self->{impl}->sr_parse_text($untokenizedText, $outputFormat);
}

sub sr_parse_tokens{
  my ($self, $request) = @_;

  my $tokenizedSentence = ($request->{'tokenizedSentence'}) ? $request->{'tokenizedSentence'} : undef;
  my $outputFormat = ($request->{'outputFormat'}) ? $request->{'outputFormat'} : undef;
  return $self->{impl}->sr_parse_tokens($tokenizedSentence, $outputFormat);
}

package CoreNLP::StanfordCoreNLPClient;


use base qw(CoreNLP::StanfordCoreNLPIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub ping{
  my $self = shift;

    $self->send_ping();
  $self->recv_ping();
}

sub send_ping{
  my $self = shift;

  $self->{output}->writeMessageBegin('ping', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_ping_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_ping{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_ping_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  return;
}
sub zip{
  my $self = shift;

    $self->send_zip();
}

sub send_zip{
  my $self = shift;

  $self->{output}->writeMessageBegin('zip', TMessageType::ONEWAY, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_zip_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}
sub parse_text{
  my $self = shift;
  my $text = shift;
  my $outputFormat = shift;

    $self->send_parse_text($text, $outputFormat);
  return $self->recv_parse_text();
}

sub send_parse_text{
  my $self = shift;
  my $text = shift;
  my $outputFormat = shift;

  $self->{output}->writeMessageBegin('parse_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_parse_text_args();
  $args->{text} = $text;
  $args->{outputFormat} = $outputFormat;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parse_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_parse_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "parse_text failed: unknown result";
}
sub parse_tokens{
  my $self = shift;
  my $tokens = shift;
  my $outputFormat = shift;

    $self->send_parse_tokens($tokens, $outputFormat);
  return $self->recv_parse_tokens();
}

sub send_parse_tokens{
  my $self = shift;
  my $tokens = shift;
  my $outputFormat = shift;

  $self->{output}->writeMessageBegin('parse_tokens', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_parse_tokens_args();
  $args->{tokens} = $tokens;
  $args->{outputFormat} = $outputFormat;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parse_tokens{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_parse_tokens_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "parse_tokens failed: unknown result";
}
sub parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

    $self->send_parse_tagged_sentence($taggedSentence, $outputFormat, $divider);
  return $self->recv_parse_tagged_sentence();
}

sub send_parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

  $self->{output}->writeMessageBegin('parse_tagged_sentence', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_parse_tagged_sentence_args();
  $args->{taggedSentence} = $taggedSentence;
  $args->{outputFormat} = $outputFormat;
  $args->{divider} = $divider;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parse_tagged_sentence{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_parse_tagged_sentence_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "parse_tagged_sentence failed: unknown result";
}
sub lexicalize_parse_tree{
  my $self = shift;
  my $tree = shift;

    $self->send_lexicalize_parse_tree($tree);
  return $self->recv_lexicalize_parse_tree();
}

sub send_lexicalize_parse_tree{
  my $self = shift;
  my $tree = shift;

  $self->{output}->writeMessageBegin('lexicalize_parse_tree', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_args();
  $args->{tree} = $tree;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_lexicalize_parse_tree{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "lexicalize_parse_tree failed: unknown result";
}
sub get_entities_from_text{
  my $self = shift;
  my $text = shift;

    $self->send_get_entities_from_text($text);
  return $self->recv_get_entities_from_text();
}

sub send_get_entities_from_text{
  my $self = shift;
  my $text = shift;

  $self->{output}->writeMessageBegin('get_entities_from_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_text_args();
  $args->{text} = $text;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_entities_from_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_entities_from_text failed: unknown result";
}
sub get_entities_from_tokens{
  my $self = shift;
  my $tokens = shift;

    $self->send_get_entities_from_tokens($tokens);
  return $self->recv_get_entities_from_tokens();
}

sub send_get_entities_from_tokens{
  my $self = shift;
  my $tokens = shift;

  $self->{output}->writeMessageBegin('get_entities_from_tokens', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_tokens_args();
  $args->{tokens} = $tokens;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_entities_from_tokens{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_tokens_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_entities_from_tokens failed: unknown result";
}
sub get_entities_from_trees{
  my $self = shift;
  my $trees = shift;

    $self->send_get_entities_from_trees($trees);
  return $self->recv_get_entities_from_trees();
}

sub send_get_entities_from_trees{
  my $self = shift;
  my $trees = shift;

  $self->{output}->writeMessageBegin('get_entities_from_trees', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_trees_args();
  $args->{trees} = $trees;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get_entities_from_trees{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_trees_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "get_entities_from_trees failed: unknown result";
}
sub resolve_coreferences_in_text{
  my $self = shift;
  my $text = shift;

    $self->send_resolve_coreferences_in_text($text);
  return $self->recv_resolve_coreferences_in_text();
}

sub send_resolve_coreferences_in_text{
  my $self = shift;
  my $text = shift;

  $self->{output}->writeMessageBegin('resolve_coreferences_in_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_args();
  $args->{text} = $text;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_resolve_coreferences_in_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "resolve_coreferences_in_text failed: unknown result";
}
sub resolve_coreferences_in_tokenized_sentences{
  my $self = shift;
  my $sentencesWithTokensSeparatedBySpace = shift;

    $self->send_resolve_coreferences_in_tokenized_sentences($sentencesWithTokensSeparatedBySpace);
  return $self->recv_resolve_coreferences_in_tokenized_sentences();
}

sub send_resolve_coreferences_in_tokenized_sentences{
  my $self = shift;
  my $sentencesWithTokensSeparatedBySpace = shift;

  $self->{output}->writeMessageBegin('resolve_coreferences_in_tokenized_sentences', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args();
  $args->{sentencesWithTokensSeparatedBySpace} = $sentencesWithTokensSeparatedBySpace;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_resolve_coreferences_in_tokenized_sentences{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "resolve_coreferences_in_tokenized_sentences failed: unknown result";
}
sub resolve_coreferences_in_trees{
  my $self = shift;
  my $trees = shift;

    $self->send_resolve_coreferences_in_trees($trees);
  return $self->recv_resolve_coreferences_in_trees();
}

sub send_resolve_coreferences_in_trees{
  my $self = shift;
  my $trees = shift;

  $self->{output}->writeMessageBegin('resolve_coreferences_in_trees', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_args();
  $args->{trees} = $trees;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_resolve_coreferences_in_trees{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "resolve_coreferences_in_trees failed: unknown result";
}
sub evaluate_tregex_pattern{
  my $self = shift;
  my $parseTree = shift;
  my $tregexPattern = shift;

    $self->send_evaluate_tregex_pattern($parseTree, $tregexPattern);
  return $self->recv_evaluate_tregex_pattern();
}

sub send_evaluate_tregex_pattern{
  my $self = shift;
  my $parseTree = shift;
  my $tregexPattern = shift;

  $self->{output}->writeMessageBegin('evaluate_tregex_pattern', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_args();
  $args->{parseTree} = $parseTree;
  $args->{tregexPattern} = $tregexPattern;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_evaluate_tregex_pattern{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "evaluate_tregex_pattern failed: unknown result";
}
sub tag_text{
  my $self = shift;
  my $untokenizedText = shift;

    $self->send_tag_text($untokenizedText);
  return $self->recv_tag_text();
}

sub send_tag_text{
  my $self = shift;
  my $untokenizedText = shift;

  $self->{output}->writeMessageBegin('tag_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_tag_text_args();
  $args->{untokenizedText} = $untokenizedText;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tag_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_tag_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "tag_text failed: unknown result";
}
sub tag_tokenized_sentence{
  my $self = shift;
  my $tokenizedSentence = shift;

    $self->send_tag_tokenized_sentence($tokenizedSentence);
  return $self->recv_tag_tokenized_sentence();
}

sub send_tag_tokenized_sentence{
  my $self = shift;
  my $tokenizedSentence = shift;

  $self->{output}->writeMessageBegin('tag_tokenized_sentence', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_args();
  $args->{tokenizedSentence} = $tokenizedSentence;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tag_tokenized_sentence{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "tag_tokenized_sentence failed: unknown result";
}
sub untokenize_sentence{
  my $self = shift;
  my $sentenceTokens = shift;

    $self->send_untokenize_sentence($sentenceTokens);
  return $self->recv_untokenize_sentence();
}

sub send_untokenize_sentence{
  my $self = shift;
  my $sentenceTokens = shift;

  $self->{output}->writeMessageBegin('untokenize_sentence', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_untokenize_sentence_args();
  $args->{sentenceTokens} = $sentenceTokens;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_untokenize_sentence{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_untokenize_sentence_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "untokenize_sentence failed: unknown result";
}
sub tokenize_text{
  my $self = shift;
  my $arbitraryText = shift;

    $self->send_tokenize_text($arbitraryText);
  return $self->recv_tokenize_text();
}

sub send_tokenize_text{
  my $self = shift;
  my $arbitraryText = shift;

  $self->{output}->writeMessageBegin('tokenize_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_tokenize_text_args();
  $args->{arbitraryText} = $arbitraryText;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tokenize_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_tokenize_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "tokenize_text failed: unknown result";
}
sub sr_parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

    $self->send_sr_parse_tagged_sentence($taggedSentence, $outputFormat, $divider);
  return $self->recv_sr_parse_tagged_sentence();
}

sub send_sr_parse_tagged_sentence{
  my $self = shift;
  my $taggedSentence = shift;
  my $outputFormat = shift;
  my $divider = shift;

  $self->{output}->writeMessageBegin('sr_parse_tagged_sentence', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_args();
  $args->{taggedSentence} = $taggedSentence;
  $args->{outputFormat} = $outputFormat;
  $args->{divider} = $divider;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_sr_parse_tagged_sentence{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "sr_parse_tagged_sentence failed: unknown result";
}
sub sr_parse_text{
  my $self = shift;
  my $untokenizedText = shift;
  my $outputFormat = shift;

    $self->send_sr_parse_text($untokenizedText, $outputFormat);
  return $self->recv_sr_parse_text();
}

sub send_sr_parse_text{
  my $self = shift;
  my $untokenizedText = shift;
  my $outputFormat = shift;

  $self->{output}->writeMessageBegin('sr_parse_text', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_sr_parse_text_args();
  $args->{untokenizedText} = $untokenizedText;
  $args->{outputFormat} = $outputFormat;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_sr_parse_text{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_sr_parse_text_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "sr_parse_text failed: unknown result";
}
sub sr_parse_tokens{
  my $self = shift;
  my $tokenizedSentence = shift;
  my $outputFormat = shift;

    $self->send_sr_parse_tokens($tokenizedSentence, $outputFormat);
  return $self->recv_sr_parse_tokens();
}

sub send_sr_parse_tokens{
  my $self = shift;
  my $tokenizedSentence = shift;
  my $outputFormat = shift;

  $self->{output}->writeMessageBegin('sr_parse_tokens', TMessageType::CALL, $self->{seqid});
  my $args = new CoreNLP::StanfordCoreNLP_sr_parse_tokens_args();
  $args->{tokenizedSentence} = $tokenizedSentence;
  $args->{outputFormat} = $outputFormat;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_sr_parse_tokens{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new CoreNLP::StanfordCoreNLP_sr_parse_tokens_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "sr_parse_tokens failed: unknown result";
}
package CoreNLP::StanfordCoreNLPProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_ping {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_ping_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_ping_result();
    $self->{handler}->ping();
    $output->writeMessageBegin('ping', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_zip {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_zip_args();
    $args->read($input);
    $input->readMessageEnd();
    $self->{handler}->zip();
    return;
}
sub process_parse_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_parse_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_parse_text_result();
    $result->{success} = $self->{handler}->parse_text($args->text, $args->outputFormat);
    $output->writeMessageBegin('parse_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_parse_tokens {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_parse_tokens_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_parse_tokens_result();
    $result->{success} = $self->{handler}->parse_tokens($args->tokens, $args->outputFormat);
    $output->writeMessageBegin('parse_tokens', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_parse_tagged_sentence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_parse_tagged_sentence_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_parse_tagged_sentence_result();
    $result->{success} = $self->{handler}->parse_tagged_sentence($args->taggedSentence, $args->outputFormat, $args->divider);
    $output->writeMessageBegin('parse_tagged_sentence', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_lexicalize_parse_tree {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_lexicalize_parse_tree_result();
    $result->{success} = $self->{handler}->lexicalize_parse_tree($args->tree);
    $output->writeMessageBegin('lexicalize_parse_tree', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_entities_from_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_text_result();
    $result->{success} = $self->{handler}->get_entities_from_text($args->text);
    $output->writeMessageBegin('get_entities_from_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_entities_from_tokens {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_tokens_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_tokens_result();
    $result->{success} = $self->{handler}->get_entities_from_tokens($args->tokens);
    $output->writeMessageBegin('get_entities_from_tokens', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get_entities_from_trees {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_get_entities_from_trees_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_get_entities_from_trees_result();
    $result->{success} = $self->{handler}->get_entities_from_trees($args->trees);
    $output->writeMessageBegin('get_entities_from_trees', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_resolve_coreferences_in_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_text_result();
    $result->{success} = $self->{handler}->resolve_coreferences_in_text($args->text);
    $output->writeMessageBegin('resolve_coreferences_in_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_resolve_coreferences_in_tokenized_sentences {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_tokenized_sentences_result();
    $result->{success} = $self->{handler}->resolve_coreferences_in_tokenized_sentences($args->sentencesWithTokensSeparatedBySpace);
    $output->writeMessageBegin('resolve_coreferences_in_tokenized_sentences', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_resolve_coreferences_in_trees {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_resolve_coreferences_in_trees_result();
    $result->{success} = $self->{handler}->resolve_coreferences_in_trees($args->trees);
    $output->writeMessageBegin('resolve_coreferences_in_trees', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_evaluate_tregex_pattern {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_evaluate_tregex_pattern_result();
    $result->{success} = $self->{handler}->evaluate_tregex_pattern($args->parseTree, $args->tregexPattern);
    $output->writeMessageBegin('evaluate_tregex_pattern', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tag_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_tag_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_tag_text_result();
    $result->{success} = $self->{handler}->tag_text($args->untokenizedText);
    $output->writeMessageBegin('tag_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tag_tokenized_sentence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_tag_tokenized_sentence_result();
    $result->{success} = $self->{handler}->tag_tokenized_sentence($args->tokenizedSentence);
    $output->writeMessageBegin('tag_tokenized_sentence', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_untokenize_sentence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_untokenize_sentence_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_untokenize_sentence_result();
    $result->{success} = $self->{handler}->untokenize_sentence($args->sentenceTokens);
    $output->writeMessageBegin('untokenize_sentence', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tokenize_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_tokenize_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_tokenize_text_result();
    $result->{success} = $self->{handler}->tokenize_text($args->arbitraryText);
    $output->writeMessageBegin('tokenize_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_sr_parse_tagged_sentence {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_sr_parse_tagged_sentence_result();
    $result->{success} = $self->{handler}->sr_parse_tagged_sentence($args->taggedSentence, $args->outputFormat, $args->divider);
    $output->writeMessageBegin('sr_parse_tagged_sentence', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_sr_parse_text {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_sr_parse_text_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_sr_parse_text_result();
    $result->{success} = $self->{handler}->sr_parse_text($args->untokenizedText, $args->outputFormat);
    $output->writeMessageBegin('sr_parse_text', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_sr_parse_tokens {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new CoreNLP::StanfordCoreNLP_sr_parse_tokens_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new CoreNLP::StanfordCoreNLP_sr_parse_tokens_result();
    $result->{success} = $self->{handler}->sr_parse_tokens($args->tokenizedSentence, $args->outputFormat);
    $output->writeMessageBegin('sr_parse_tokens', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
