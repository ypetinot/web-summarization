// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "../../gen-cpp/Word2Vec.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::concurrency;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

//#include <google/dense_hash_map>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PosixThreadFactory.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/TToString.h>

#include <fstream>
#include <iostream>
#include <math.h>
#include <stdexcept>
#include <sstream>

#include <boost/numeric/ublas/vector_sparse.hpp>

const long long max_size = 2000;         // max length of strings
const long long N = 40;                  // number of closest words that will be shown
const long long max_w = 50;              // max length of vocabulary entries

using namespace boost::numeric::ublas;
using boost::shared_ptr;

class Word2VecHandler : virtual public Word2VecIf {

protected:
  
  float *M;
  long long words;
  long long size;

  char st1[max_size];

  char *vocab;

  /* null vector */
  boost::numeric::ublas::zero_vector<float> zero;

  /* word to position map */
  //  google::dense_hash_map<string,long long> word_to_position;

public:
  Word2VecHandler( string file_name ) {

    //word_to_position.set_empty_key( "[[__EMPTRY_KEY__]]" );

    // Load word2vec model
    char st[100][max_size];

    float len;
    long long a, c, d, bi[100];
    char ch;

    //ifstream f;
    FILE *f;

    cout << "Loading vector space from: " << file_name << endl;
    //f.open( file_name.c_str() , ios::in | ios::binary );
    f = fopen( file_name.c_str() , "rb" );

    //if ( ! f.is_open() ) {
    if ( f == NULL ) {
      throw("Invalid model file ...");
    }

    //f >> words;
    /* note: we introduce n_read_words only to suppress unused-result warnings */
    int n_read_words = fscanf(f, "%lld", &words);
    cout << "number of words : " << words << endl;

    //f >> size;
    /* note: we introduce n_read_size only to suppress unused-result warnings */
    int n_read_size = fscanf(f, "%lld", &size);
    cout << "size : " << size << endl;

    /* initialize null vector */
    zero = boost::numeric::ublas::zero_vector<float>( size );

    //    vocab = (char *)malloc((long long)words * max_w * sizeof(char));
    vocab = new char[ ((long long)words * max_w * sizeof(char)) ];

    // M = (float *)malloc((long long)words * (long long)size * sizeof(float));
    M = new float[ ((long long)words * (long long)size * sizeof(float)) ];

    if (M == NULL) {
      throw ("Cannot allocate memory: %lld MB    %lld  %lld\n", (long long)words * size * sizeof(float) / 1048576, words, size);
    }
    for (long long b = 0; b < words; b++) {
      a = 0;

      while ( 1 ) {
	long long vocab_index = b * max_w + a;

	//f.get( vocab + vocab_index , 1 );
	vocab[ vocab_index ] = fgetc(f);

	//if (f.eof() || (vocab[ vocab_index ] == ' ')) break;
	if ( feof(f) || ( vocab[ vocab_index ] == ' ' ) ) break;

	if ((a < max_w) && (vocab[ vocab_index ] != '\n')) a++;
      }
      vocab[b * max_w + a] = 0;

      /* TODO : reinterpret_cast seems to be a terrible idea */
      /* http://stackoverflow.com/questions/2473628/c-cant-static-cast-from-double-to-int */
      //for (a = 0; a < size; a++) f.read( reinterpret_cast<char*>( &M[a + b * size] ), sizeof(float) );
      for (a = 0; a < size; a++)
	/* note: we introduce n_read only to suppress unused-result warnings */
	int n_read = fread( &M[a + b * size] , sizeof(float) , 1 , f );

      len = 0;
      for (a = 0; a < size; a++) len += M[a + b * size] * M[a + b * size];
      len = sqrt(len);
      for (a = 0; a < size; a++) M[a + b * size] /= len;

      /* CURRENT : is this even necessary ? check vocab_index above */
      /* store word position */
      //word_to_position[ word ] = b;

    }

    //f.close();
    fclose( f );
    
  }

  long long _get_vocabulary_position( string word ) {

    long long b;

    // TODO : implement some for of binary search here ?
    for (b = 0; b < words; b++) if (!strcmp(&vocab[b * max_w], word.c_str())) break;

    cout << endl << "Word: " << word << " ";

    // TODO : print status via shared string => reduce code duplication
    if (b == words) {
      cout << "[out of vocabulary]";
      b = -1;
    }
    else {
      cout << "Position in vocabulary: " << b;
    }

    cout << endl;

    return b;

  }

  const std::vector<ScoredString> _get_nearest_vocabulary( const boost::numeric::ublas::vector<float> vec , long n_requested , std::vector<long long> exclude ) {

    long long a, c;
    float dist;

    std::vector<long long>::const_iterator exclude_iter;

    /* we look for more locations than actually requested , accounting for locations that may match the exclude list */
    long n_adjusted = n_requested + exclude.size();
    float bestd[n_adjusted];
    long long besti[n_adjusted];
    char bestw[n_adjusted][max_size];

    for (a = 0; a < n_adjusted; a++) bestd[a] = 0;
    for (a = 0; a < n_adjusted; a++) bestw[a][0] = 0;
    for (c = 0; c < words; c++) {

      /* Note : this totally looks redundant with what's coming just before ... remove ?
	 a = 0;
	 for (b = 0; b < 3; b++) if (bi[b] == c) a = 1;
	 if (a == 1) continue;
      */
      
      /* compute distance with the current word */
      /* Note : is there a way to optimize / speed this up ? */
      dist = 0;
      for (a = 0; a < size; a++) dist += vec[a] * M[a + c * size];
      for (a = 0; a < n_adjusted; a++) {
        if (dist > bestd[a]) {
          for (long long d = n_adjusted - 1; d > a; d--) {
            bestd[d] = bestd[d - 1];
	    besti[d] = besti[d - 1];
            strcpy(bestw[d], bestw[d - 1]);
          }
          bestd[a] = dist;
	  besti[a] = c;
          strcpy(bestw[a], &vocab[c * max_w]);
          break;
        }
      }

    }

    std::vector<ScoredString> results;

    cout << endl << "                                              Word              Distance\n------------------------------------------------------------------------" << endl;
    for (a = 0; a < n_adjusted; a++) {

      /* TODO : keep track of vocabulary position */
      bool do_exclude = false;
      exclude_iter = exclude.begin();
      while( exclude_iter != exclude.end() ) {
	if ( besti[ a ] == *exclude_iter++ ) {
	  do_exclude = true;
	  break;
	}
      }

      if ( do_exclude ) {
	continue;
      }

      cout << bestw[ a ] << "\t\t" << bestd[ a ] << endl;

      ScoredString word_entry;
      word_entry.word = bestw[ a ];
      word_entry.score = bestd[ a ];
      results.push_back( word_entry );
    }

    return results;

  }

  void ping() { cout << "ping()" << endl; }

  /**
   * Prints 'testList("{%s}")' where thing has been formatted into a string of  values
   *  separated by commas and new lines
   * @param list<i32> thing - the list<i32> to print
   * @return list<i32> - returns the list<i32> 'thing'
   * 
   * @param word1
   * @param word2
   * @param word3
   */
  void analogy(std::vector<ScoredString> & _return, const std::string& word1, const std::string& word2, const std::string& word3) {

    cout << "analogy(" << word1 << ", " << word2 << ", " << word3 << ")" << endl;

    long long a;
    std::vector<long long> bi( 3 );

    boost::numeric::ublas::vector<float> vec1 = get_coordinates( word1 );
    boost::numeric::ublas::vector<float> vec2 = get_coordinates( word2 );
    boost::numeric::ublas::vector<float> vec3 = get_coordinates( word3 );

    /* TODO : we should be throwing exceptions instead */
    bool can_proceed = ( ! boost::numeric::ublas::norm_1( vec1 ) ||
			 ! boost::numeric::ublas::norm_1( vec2 ) ||
			 ! boost::numeric::ublas::norm_1( vec3 ) );
    if ( ! can_proceed ) {
      return;
    }

    /* vector computation - specific to the analogy problem */
    boost::numeric::ublas::vector<float> vec = vec2 - vec1 + vec3;
    vec /= boost::numeric::ublas::norm_2( vec );

    _return = _get_nearest_vocabulary( vec , N , bi );

  }

  /**
   * Returns the distance between two words
   * @param string word1 - the first word
   * @param string word2 - the second word
   * @return float - distance between word1 and word2
   * 
   * @param word1
   * @param word2
   */
  double distance(const std::string& word1, const std::string& word2) {

    /* 1 - get coordinates for word1 */
    boost::numeric::ublas::vector<float> vec1 = get_coordinates( word1 );

    /* 2 - get coordinates for word2 */
    boost::numeric::ublas::vector<float> vec2 = get_coordinates( word2 );

    /* 3 - compute distance */
    double distance = boost::numeric::ublas::norm_2( vec1 - vec2 );

    return distance;

  }

  /**
   * Returns the cosine similarity between two words
   * @param string word1 - the first word
   * @param string word2 - the second word
   * @param double rescale - how much to rescale vectors for cosine computation
   * @return float - cosine similarity between word1 and word2
   * 
   * @param word1
   * @param word2
   */
  double cosine_similarity(const std::string& word1, const std::string& word2 ) {

    /* 1 - get coordinates for word1 */
    boost::numeric::ublas::vector<float> vec1 = get_coordinates( word1 );
    
    /* 2 - get coordinates for word2 */
    boost::numeric::ublas::vector<float> vec2 = get_coordinates( word2 );
    
    /* 3 - compute cosine similarity */
    double inner_prod = boost::numeric::ublas::inner_prod( vec1 , vec2 );

    /* Note : if the inner product is not a number this means (?) that at least one of the two vectors was the null vector */
    double cosine_similarity = ( inner_prod == 0 || isnan( inner_prod ) ) ? 0 : ( inner_prod / ( boost::numeric::ublas::norm_2( vec1 ) * boost::numeric::ublas::norm_2( vec2 ) ) );

    cout << "Cosine similarity ( " << word1 << " , " << word2 << " ) : " << inner_prod << " " << cosine_similarity << endl;

    return cosine_similarity;

  } 

  const boost::numeric::ublas::vector<float> get_coordinates( const std::string& word ) {
    
    boost::numeric::ublas::vector<float> coordinates( size );

    /* 1 - attempt to get coordinates for word as a phrase */
    coordinates = _get_coordinates( word );

    /* 2 - attempt to get coordinates using compositionality */
    if ( ! boost::numeric::ublas::norm_1( coordinates ) ) {

      cout << "Will process " << word << " using compositionality ... " << endl;

      istringstream word_ss( word );
      std::vector<string> words;
      copy( istream_iterator<string>( word_ss ),
	    istream_iterator<string>(),
	    back_inserter(words) );
      
      for ( std::vector<string>::iterator it=words.begin(); it!=words.end(); ++it ) {
	coordinates += _get_coordinates( *it );
      }

      /* TODO : turn this into a method to avoid code duplication */
      coordinates /= boost::numeric::ublas::norm_2( coordinates );

    }

    return coordinates;

  }

  const boost::numeric::ublas::vector<float> _get_coordinates( const std::string& word ) {

    /* 0 - replace white spaces with underscores */
    string word_normalized = word;
    std::replace( word_normalized.begin() , word_normalized.end() , ' ', '_' );

    /* 1 - determine vocabulary position */
    long long vocabulary_position = _get_vocabulary_position( word_normalized );

    if ( vocabulary_position == -1 ) {
      // TODO : should we return an exception instead ?
      return zero;
    }

    /* 2 - retrieve coordinates */
    boost::numeric::ublas::vector<float> coordinates( size );
    for (long a = 0; a < size; a++) {
      coordinates[ a ] = M[ a + vocabulary_position * size ];
      /*
      if ( coordinates[ a ] < 0 ) {
      	cout << "Found negative coordinate: " << a << " / " << coordinates[ a ] << endl;
      }
      */
    }    

    return coordinates;

  }

  /* nearest neighbor / phrase => coordinates computed by summing up the coordinates of individual terms */

};

  /* TODO : add command line parameter to control the type of server that should be instantiated */
int main(int argc, char **argv) {

  int port = 9090;

  string filename_model( argv[ 1 ] );
  shared_ptr<Word2VecHandler> handler(new Word2VecHandler( filename_model ));
  shared_ptr<TProcessor> processor(new Word2VecProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  /**
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  */

  const int workerCount = 800;

  boost::shared_ptr<ThreadManager> threadManager = ThreadManager::newSimpleThreadManager(workerCount);
  boost::shared_ptr<PosixThreadFactory> threadFactory = boost::shared_ptr<PosixThreadFactory>(new PosixThreadFactory());

  threadManager->threadFactory(threadFactory);
  threadManager->start();

  //  /* previous version
  TThreadPoolServer server(processor,
                           serverTransport,
                           transportFactory,
                           protocolFactory,
                           threadManager);
  //*/

  /* limited by ulimit -n (1024) => accept() Too many open files
  TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);
  */

  //  TNonblockingServer server(processor, protocolFactory, port, threadManager);
  //TNonblockingServer server(processor, protocolFactory, port, threadManager);

  cout << "Starting the server..." << endl;
  server.serve();
  cout << "Done." << endl;

  return 0;

}
