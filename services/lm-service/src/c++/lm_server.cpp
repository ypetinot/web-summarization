// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "LMService.h"
#include <google/dense_hash_map>
#include <fstream>
#include <iostream>
#include <string>
#include <sstream>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/server/TThreadedServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace  ::std;
using namespace  ::service::nlp;

class LMServiceHandler : virtual public LMServiceIf {

  /* total ngram count */
  int64_t ngram_total_count;
  
  /* ngram to count map */
  google::dense_hash_map<string,long> ngram_to_count;
  
public:
  LMServiceHandler( string filename_model ):ngram_total_count(0) {
    
    /* load count data */
    _load_count_data( filename_model );
    
  }

  void _load_count_data( string filename_model ) {

    ngram_to_count.set_empty_key( "[[__EMPTRY_KEY__]]" );
    ifstream counts_ifs( filename_model.c_str() );

    cout << "Loading n-gram counts ..." << endl;

    long total_count = 0;
    while ( ! counts_ifs.eof() ) {
    
      string line;
      getline( counts_ifs , line );

      stringstream ss( line );

      /* read ngram */
      string ngram;
      getline( ss , ngram , '\t' );

      /* read count */
      long count;
      ss >> count;

      /* store ngram count */
      ngram_to_count[ ngram ] = count;

      /* update total count */
      ngram_total_count += count;

      if ( ! ( ++total_count % 10000 ) ) {
	cout << "Loading n-gram counts : " << total_count << endl;
      }

    }

    cout << "Done loading n-gram counts !" << endl;

  }

  /**
   * Returns global count for the specified model and word sequence
   * @param string model_key
   * @param string sequence
   * @return i64 - global count
   * 
   * @param model_key
   * @param sequence
   */
  int64_t global_count(const std::string& model_key, const std::string& sequence) {
    
    /* CURRENT : does SRILM provide an API to get the counts information ? */
    /* => if yes, then use SRILM */
    /* => if no, then simply load the data using my data format */

    int64_t return_count;

    if ( sequence.length() ) {

      return_count = ngram_to_count[ sequence ];
      cout << "Requested global count for "
	   << model_key << "/" << sequence << " : "
	   << return_count << endl;
      
    }
    else {

      return_count = ngram_total_count;

    }

    return return_count;
    
  }

};

int main(int argc, char **argv) {

  // TODO : turn into an input parameter
  int port = 9595;

  string filename_model( argv[ 1 ] );

  boost::shared_ptr<LMServiceHandler> handler(new LMServiceHandler( filename_model ));
  boost::shared_ptr<TProcessor> processor(new LMServiceProcessor(handler));
  boost::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  boost::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  boost::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  //TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  TThreadedServer server(processor,
                         serverTransport,
                         transportFactory,
                         protocolFactory);

  server.serve();
  return 0;

}

